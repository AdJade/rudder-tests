#!/usr/bin/python

"""
Rudder test framework

Usage:
    rtf platform list
    rtf platform status <platform>
    rtf platform setup <platform> [<version>]
    rtf platform destroy <platform>
    rtf platform update-rudder <platform> <version>
    rtf platform update-os <platform> <version>
    rtf host list <platform>
    rtf host update-rudder <host> <version>
    rtf host update-os <host> <version>
    rtf scenario list
    rtf scenario env <platform>
    rtf scenario run <platform> <scenario> [--no-finally] [--filter=<test1>,<test2>,...] [--format=<format>]

Options:
    --no-finally       Do not run tests tagged FINALLY in the scenario, to avoid coming back to initial state
    --filter=...       Only run provided test list from scenario
    --format=<format>  Output format to use (progress, documentation, html or json) [Default: documentation]
"""

import argparse
import json
import os
import copy
import re
import scenario.lib
import importlib
import docopt
from subprocess import check_output
from pprint import pprint


class Host:
  """Generic Host
  Inherit to create host managed by a specific provider
  Look at Vagrant class for the list of methods to implement
  """
  def __init__(self, host_info):
    self.info = host_info


### Vagrant specific code ###

def host_lines(platform, hosts, pf_id):
  """ Return a Vagrantfile host line """ 
  pf = platform.split('.')[0]
  lines=[]
  i=1
  host_list = sorted(hosts.keys(), reverse=True)
  hostnames = " ".join(host_list)
  for hostname in host_list:
    host = hosts[hostname].info
    if host['run-with'] == 'vagrant':
      os = host['system']

      if host['rudder-setup'] == 'server':
        host_id = "0"
      else:
        host_id = str(i)
        i += 1

      # Define server the node is pointing to
      own_server = ""
      if 'server' in host:
        own_server = host['server']

      line = "configure(config, $" + os + ", '" + pf + "', " + str(pf_id) + ", '" + hostname +"', " + host_id + ", '" + host['rudder-setup'] + "', '" +  host['rudder-version'] + "', '" + own_server + "', '" + hostnames + "')\n"
      lines.append(line)
  return lines

def init_vagrantfile():
  """ Initialize an empty Vagrantfile """
  if os.path.isfile("Vagrantfile"):
    return
  with open("Vagrantfile", "w") as vagrant:
    vagrant.write("""# -*- mode: ruby -*-
# vi: set ft=ruby :

require_relative 'vagrant.rb'

Vagrant.configure("2") do |config|

### AUTOGEN TAG

end
""")


class Vagrant(Host):
  """ Vagrant managed host """
  def __init__(self, platform, name, host_info):
    Host.__init__(self, host_info)
    pf = platform.split('.')[0]
    self.platform = pf
    self.name = name
    self.hostid = pf + '_' + name
    init_vagrantfile()

  def start(self):
    """ Setup and run this host """
    os.system("vagrant up " + self.hostid)

  def stop(self):
    """ Destroy this host """
    os.system("vagrant destroy -f " + self.hostid)

  def run(self, command):
    """ Run a command as root on this host """
    value = check_output("vagrant ssh " + self.hostid + " -c \"sudo PATH=$PATH:/vagrant/scripts " + command + "\" -- -q", shell=True)
    return value .rstrip()

  def get_url(self):
    """ Get matching server URL """
    # port autodetection
    port = None
    for line in open("Vagrantfile"):
      # match configure(config, pf_name, 'platform', id, 0, 'version')
      m = re.match(r'configure\((?:.*?,){2}\s*' + "'" + self.platform + "'" + r'\s*,\s*(\d+)', line)
      if m:
        port = str(int(m.group(1)) * 100 + 8081)
    if port is None:
      return None
    return "https://localhost:" + str(port) + "/rudder"

  @staticmethod
  def status(platform, hosts):
    """ Return the status of all hosts on a given platform """
    host_list = [ platform + '_' + h for h in hosts ]
    os.system("vagrant status " + " ".join(host_list))

  @staticmethod
  def reset_platform(name, hosts):
    """ Update or replace the Vagrantfile configuration for the given platform """
    lines = []
    with open("Vagrantfile", "r+") as fd:
      updated = False
      line=fd.readline()
      max_pf_id = 0
      while line:
        m = re.match(r'configure\((?:.*?,){3}\s*(\d+)', line)
        if m:
          pf_id = int(m.group(1))
          if pf_id > max_pf_id:
            max_pf_id = pf_id
        if not updated and re.match(r'### AUTOGENERATED FOR PLATFORM ' + name + r' \(\d+\)', line):
          lines.append(line)
          while not re.match(r'### END OF AUTOGENERATION FOR ' + name, line):
            line = fd.readline()
            m = re.match(r'configure\((?:.*?,){3}\s*(\d+)', line)
            if m:
              pf_id = int(m.group(1))
          lines.extend(host_lines(name, hosts, pf_id))
          lines.append(line)
          updated = True
        elif not updated and re.match(r'### AUTOGEN TAG', line):
          lines.append('### AUTOGENERATED FOR PLATFORM ' + name + " (" + str(max_pf_id+1) + ")\n")
          lines.extend(host_lines(name, hosts, max_pf_id+1))
          lines.append('### END OF AUTOGENERATION FOR ' + name + "\n")
          lines.append("\n### AUTOGEN TAG\n")
          updated = True
        else:
          lines.append(line)
        line=fd.readline()
      fd.seek(0)
      fd.truncate()
      fd.writelines(lines)

### End of vagrant specific code ###

# Global list of host type
host_types = { 'vagrant': Vagrant }



class Platform:
  """ A test platform
  Can be setup or teared down at once
  Can be used to run a test scenario
  """
  def __init__(self, name, platform_info, override):
    self.name = name
    self.hosts = {}
    # manage default values
    default = platform_info['default']
    for hostname, host in platform_info.items():
      if hostname == "default":
        continue
      host_info = copy.deepcopy(default)
      host_info.update(host)
      host_info.update(override)
      class_name = host_info['run-with']
      # New host object (Vagrant/AWS/...)
      self.hosts[hostname] = host_types[class_name](name, hostname, host_info)

  def setup(self, client_path):
    """ Startup the full platform """
    for host_type in host_types.values():
      host_type.reset_platform(self.name, self.hosts)
    for hostname in sorted(self.hosts.keys(), reverse=True):
      self.hosts[hostname].start()
    relay_list = []
    # Find all relays uuid
    for host in self.hosts.values():
      if host.info['rudder-setup'] == 'relay':
        uuid = host.run("cat /opt/rudder/etc/uuid.hive")
        relay_list.append(uuid)
    # Promote relays on servers
    for host in self.hosts.values():
      if host.info['rudder-setup'] == 'server':
        # Treat inventory received on the server
        print(host.run("/var/rudder/cfengine-community/bin/cf-agent -K"))
        # Environment setup
        rudder_url = host.get_url()
        token = host.run('cat /root/rudder-token')
        setenv(client_path, rudder_url, token)
        for relay in relay_list:
          # Accept the relay
          rcli = "rudder-cli --skip-verify --url=" + rudder_url + " --token=" + token
          command = rcli + " nodes accept "+ relay
          print(check_output(command, shell=True))
          # Promote to relay
          print(host.run("/opt/rudder/bin/rudder-node-to-relay "+relay))

  def teardown(self):
    """ Stop and destroy he full platform """
    for host in self.hosts.values():
      host.stop()

  def update_rudder(self, version):
    """ Update rudder version on all hosts """
    for host in self.hosts.values():
      print(host.run("rudder-setup upgrade-" + host.info['rudder-setup'] + " " + version))

  def status(self):
    """ Show platform status """
    for host_type in host_types.values():
      host_list = []
      for hostname,host in self.hosts.items():
        if isinstance(host, host_type):
          host_list.append(hostname)
      host_type.status(self.name, host_list)

  def run_scenario(self, name, frmt, run_finally, run_only, client_path):
    """ Run a scenario on this platform """
    # test ruby binary
    rubyver = check_output("ruby --version", shell=True)
    if re.match(r'jruby', rubyver):
      if not re.match(r'jruby 1.7', rubyver):
        print("WARNING: this is not JRuby 1.7, compatibility unknown")

    elif not re.match(r'ruby 2', rubyver):
      print("ERROR: MRI Ruby needs be version 2")
      exit(3)

    # Test rspec command
    rspec = "ruby -S rspec --order defined --fail-fast --format " + frmt
    check_output(rspec, shell=True)
  
    # Get server info
    rudder_url = None
    token = None
    for hostname, host in self.hosts.items():
      if host.info['rudder-setup'] == "server":
        rudder_url = host.get_url()
        token = host.run('cat /root/rudder-token')
    if rudder_url is None or token is None:
      print("This platform has no rudder server, can't run scenario")
      exit(2)
    rcli = "rudder-cli --skip-verify --url=" + rudder_url + " --token=" + token

    # load and run
    scenario.lib.scenario = scenario.lib.Scenario(self, rspec, rcli, frmt, run_only, run_finally)
    setenv(client_path, rudder_url, token)
    importlib.import_module("scenario." + name)

  def print_environment(self, client_path):
    """ Print environment used to run tests on this platform """
    # Get server info
    rudder_url = None
    token = None
    for hostname, host in self.hosts.items():
      if host.info['rudder-setup'] == "server":
        rudder_url = host.get_url()
        token = host.run('cat /root/rudder-token')
    setenv(client_path, rudder_url, token)
    print("export PATH=" + os.environ['PATH'])
    print("export PYTHONPATH=" + os.environ['PYTHONPATH'])
    print("export RUDDER_SERVER=" + os.environ['RUDDER_SERVER'])
    print("export RUDDER_TOKEN=" + os.environ['RUDDER_TOKEN'])


###################
# Utility methods #
###################

def setenv(client_path, url, token):
  """ Set environment variables for command calls """
  if client_path is not None:
    os.environ['PATH'] += ":" + client_path + "/cli"
    os.environ['PYTHONPATH'] = client_path +  "/lib.python"
  os.environ['RUDDER_SERVER'] = url
  os.environ['RUDDER_TOKEN'] = token

def load_json(filename):
  """ Load a commented json """
  # read json from file
  file = open(filename, 'r')
  data = file.read()
  file.close()
  data = re.sub("\\/\\/.*", "", data)
  return json.loads(data)

_platform = None
def get_platform(name, override={}):
  """ Get a platform object given its name """
  global _platform
  if _platform is not None:
    return _platform

  platform_description = load_json("platforms/" + name + ".json")
  _platform = Platform(name, platform_description, override)
  return _platform

def list_platforms():
  """ List available platforms """
  for file in os.listdir("platforms"):
    print(file.replace(".json", ""))

def list_scenarii():
  """ List available scenarios """
  for f in os.listdir("scenario"):
    if not f.endswith(".py"):
      continue
    file = f.replace(".py", "")
    if file != "__init__" and file != "lib":
      print(file)


##########################
# Command line interface #
##########################

if __name__ == "__main__":
  args = docopt.docopt(__doc__)
  # Hack nedded because there is not api client package yet
  client_path = "rudder-api-client"
  if not os.path.exists(client_path):
    print("Can't find rudder-api-client, if you install rudder-api-client package, you should patch this script")
    print("If you want to use rudder-api-client from a local repository please type this command:")
    print("ln -s ~/<path_to>/rudder-api-client")
    exit(1)
  
  if args['platform']:
    if args['list']:
      list_platforms()
    else:
      if args['status']:
        platform = get_platform(args['<platform>'])
        platform.status()
      elif args['setup']:
        override = {}
        if args['<version>'] is not None:
          override['rudder-version'] = args['<version>']
        platform = get_platform(args['<platform>'], override)
        platform.setup(client_path)
      elif args['destroy']:
        platform = get_platform(args['<platform>'])
        platform.teardown()
      elif args['update-rudder']:
        platform = get_platform(args['<platform>'])
        platform.update_rudder(args['<version>'])
      elif args['update-os']:
        pass
  elif args['host']:
    pass
  elif args['scenario']:
    if args['list']:
      list_scenarii()
    elif args['env']:
      platform = get_platform(args['<platform>'])
      platform.print_environment(client_path)
    elif args['run']:
      filter=args['--filter']
      if filter == []:
        filter = None

      platform = get_platform(args['<platform>'])
      platform.run_scenario(args['<scenario>'], args['--format'], not args['--no-finally'], filter, client_path)

